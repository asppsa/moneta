#!/usr/bin/env ruby

ENV['PARALLEL_TESTS'] = 'yes'

files = Dir['spec/**/*_spec.rb', 'test/**/*_test.rb'].sort
require 'multi_json'

def tag_args tags
  tags.flat_map{ |tag| ['--tag', tag] }
end

def example_ids tags, specs
  json = `bundle exec rspec -f j --dry-run #{tag_args(tags).join(' ')} -- #{specs.join(' ')}`
  data = MultiJson.load(json)
  data['examples'].map{ |example| example['id'] }
end

# Shuffle specs to ensure equal distribution over the test groups
# We have to shuffle with the same seed every time because rake is started
# multiple times!
old_seed = srand(43)
files.shuffle!
srand(old_seed)

n, max = if ARGV.first and matches = ARGV.first.match(/^(\d+)\/(\d+)$/)
					 ARGV.shift
           matches[1..-1].map(&:to_i)
				 else
				   [1, 1]
  			 end

if n == max
  files = files[(n - 1) * (files.size / max)..-1]
else
  files = files[(n - 1) * (files.size / max), files.size / max]
end

specs, tests = files.partition { |file| file.match /_spec\.rb$/ }

puts "The following specs will be executed:\n\t#{specs.join "\n\t"}\n\n" unless specs.empty?
puts "The following tests will be executed:\n\t#{tests.join "\n\t"}\n\n" unless tests.empty?

tags = ARGV.dup
results = []
unless specs.empty?
  # run all non :isolate examples in parallel
  results << system(*%w{bundle exec parallel_rspec --},
                    *tag_args(tags | %w{~isolate}),
                    '--',
                    *specs)

  # find the example IDs of the isolate examples to be run in serial
  ids = example_ids(tags, specs) - example_ids(tags | %w{~isolate}, specs)
  unless ids.empty?
    results << system(*%w{bundle exec rspec},
                      '--',
                      *ids)
  end
end

tests.each do |test|
  results << system(*%w{bundle exec ruby}, test)
end

if results.any?{ |result| !result }
  puts "\e[31m########## MONETA TESTSUITE FAILED ##########\e[0m"
  exit 1
end

puts "\e[32m########## MONETA TESTSUITE SUCCEDED ##########\e[0m"
